#+TITLE: Emacs Julia

#+PROPERTY: header-args :eval never-export :noweb yes :mkdirp yes :dir ~/treemax/.spacemacs.d/layers/treemax-julia/local/libjulia
#+PROPERTY: header-args:shell :results output verbatim drawer replace :tangle-mode (identity #o755)
#+OPTIONS: num:nil toc:nil

* What is this?

NOTE: This project is in-development not ready for production use! See the end of this document for notes on how to contribute.

NOTE: There is a currently an effort to move this to use [[https://github.com/tromey/emacs-ffi][emacs-ffi]]. See [[file:julia-ffi.el][julia-ffi.el]]. These docs still reflect the original attempt, which directly used the dynamic module interface.

Julia is designed to be [[https://docs.julialang.org/en/v1/manual/embedding/index.html%20][embeddable]]. This project uses Julia's C API to create an [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Dynamic-Modules.html][Emacs dynamic module]], thereby embedding Julia into Emacs. When loaded into a running Emacs process, the dynamic module registers new Emacs Lisp functions that (indirectly) call Julia's C API functions. To see this in action, skip to the [[*Basic verification][Basic verification]] section.

* Why?

** Augmenting Julia Development Tools in Emacs

One of Julia's primary shortcomings is its lack development tools. Emacs is a powerful environment for building and using development tools, especially for languages in the the Lisp family. This project gives Emacs Lisp direct and efficient access to Juila's runtime in hopes of aiding the development of features like:

- Structure editing (like [[http://danmidwood.com/content/2014/11/21/animated-paredit.html][paredit]], [[https://github.com/Fuco1/smartparens][smartparens]], and [[https://github.com/abo-abo/lispy][lispy]])
- Step-by-step debugging
- Inline expression evaluation
- Inline macro-expansion
- Inline views of lowered / compiled forms
- Hooks for tools like [[https://github.com/magnars/expand-region.el][expand-region]]
- Code auto-formatting

Note that Emacs already has an interface to Julia via the [[https://github.com/tpapp/julia-repl][Julia REPL]], a [[https://github.com/JuliaEditorSupport/LanguageServer.jl][Language Server]], and [[https://github.com/dzop/emacs-jupyter][Jupyter kernels]]. However, none of them currently provide any of these features.

Also note that most of these are considered standard features for working with Lisps in Emacs.

** Augmenting Emacs with Julia

Some Emacs extension could benefit from being partially written in Julia. This project directly enables this possibility.

* Getting Started
** Requirements

- Emacs Lisp experience. There is currently very little use of this package other than to aid in developing Emacs Lisp tools for Julia.
- Emacs 25+ that you can build from source.
- A =libjulia.so= from Julia 1.0+.
  - This is in =/usr/local/lib= if you [[https://github.com/JuliaLang/julia#source-download-and-compilation][build Julia from source]] with =prefix=/usr/local= set in the =Make.user= file.
- Perseverance. This is not (yet) a 1-click install.

*NOTE: This has only been tested on Ubuntu 16.04.5 with Emacs 27.0.5 and Julia 1.0.2*.

I suspect this works on most modern GNU/Linux systems, and that OSX can be made to work with some tweaks.

** Compile Emacs

We need to compile Emacs with module support using the =--with-modules= configure option:

#+BEGIN_SRC shell
./configure --with-modules
make
#+END_SRC

If the build succeeds, your new Emacs executable will be =src/emacs=. Run =make install= as root to install it to your system.

NB: You can speed up compilation significantly by using the =-j<n>= [[https://www.gnu.org/software/make/manual/html_node/Options-Summary.html][flag]] to =make= for a parallel build.

** Configure shared library directories

(If you installed Julia to a =/usr/local/=, you can likely skip this step.)

You need to ensure the directory containing the Julia shared library =libjulia.so= (built by default when compiling Julia) is in the list of paths =ld= searches when dynamically linking. Do this with the =ldconfig= utility or by setting =LD_LIBRARY_PATH=<julia_lib_dir>=.

NB: Emacs won't load a dynamic module more than once, so you'll have to restart Emacs to test changes like this. =make test= will spawn a fresh Emacs process for you, which is helpful in cases like this.

NB2: On Linux you can quickly find the library location by running =find / -name "\*libjulia.so\*".=

See [[http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html][this thorough document]] for information about shared libraries, =ldconfig=, and =LD_LIBRARY_PATH=.

** Install the Emacs package

1. Clone this repository into your Emacs load path.
2. Run your freshly-built Emacs in an environment aware of =libjulia.so= (see previous section).
3. Evaluate =(require 'julia)= and go through the first-load compilation steps (don't mind the =gcc= warnings).

If successful, =julia-core.so= should be compiled and loaded into your Emacs process. Your =*Messages*= buffer should contain the line:

#+BEGIN_EXAMPLE
Loading <install-dir>/julia-core.so (module)...done
#+END_EXAMPLE

** Basic verification

Verify the bindings work by trying to call one of the functions exposed by =julia-core.so= from Emacs Lisp. For example:

#+BEGIN_SRC emacs-lisp :exports both
(julia-eval "x = 42")
(julia-eval "EmacsJulia.clean_sexpr(\"1\")")
#+END_SRC

#+RESULTS:
: MethodError

Notice:

- There is no Emacs Lisp definition for =julia-eval=. It is implemented in C in =julia-core.c= and wraps =jl_eval_string= from Julia's C API.
- No Julia process is spawned for this evaluation. Instead, Julia and Emacs share a single process.
- Julia retains state between calls from Emacs Lisp.

* Development
** Re-building the shared library

You should only need to do this if you modify the C sources.

From the top-level directory of this repository, run:

#+BEGIN_SRC shell
make
#+END_SRC

#+RESULTS:
:RESULTS:
rm *.o *.so
Makefile:15: recipe for target 'clean' failed
gcc emacs-module-helpers.c julia-core.c --shared -Wall -std=gnu99 -I'/home/dan/julia/usr/include/julia' -DJULIA_ENABLE_THREADING=1 -fPIC -L'/home/dan/julia/usr/lib' -Wl,--export-dynamic -Wl,-rpath,'/home/dan/julia/usr/lib' -Wl,-rpath,'/home/dan/julia/usr/lib/julia' -ljulia -o julia-core.so
gcc emacs-module-helpers.c julia-core.c --shared -Wall -std=gnu99 -I'/home/dan/julia/usr/include/julia' -DJULIA_ENABLE_THREADING=1 -fPIC -L'/home/dan/julia/usr/lib' -Wl,--export-dynamic -Wl,-rpath,'/home/dan/julia/usr/lib' -Wl,-rpath,'/home/dan/julia/usr/lib/julia' -ljulia -o julia-core.so
./bin/emacs --module-assertions -nw -Q -batch -L . -l ert -l julia-tests.el --eval "(ert-run-tests-batch-and-exit)"
Exception from jl_eval_string: UndefVarError
Returning exception string to Emacs.
:END:

In case you need it, =make clean= wipes away the object files and shared library.

** Running the tests

Tests run in a separate Emacs process in "batch" mode (so no new Emacs frame will appear).

From the top-level directory of this repository, run:

#+BEGIN_SRC shell
make && make test-ffi
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

* Status / Development Notes
** Data Marshalling
*** Emacs -> Julia

Not started.

For now we serialize any data from Emacs into a string representations of Julia code, then just =eval= it.

e.g.

#+BEGIN_EXAMPLE emacs-lisp
(julia-within-lib-dir
             (julia-eval-blind
              (with-temp-buffer
                (insert-file-contents-literally "EmacsJulia/src/EmacsJulia.jl")
                (buffer-string))))
#+END_EXAMPLE

*** Julia -> Emacs [2/5]
- [X] integers, floats
- [X] strings
- [ ] 1d arrays
- [ ] multi-dimensional arrays
- [ ] arbitrary serialize-able objects

Maybe we can just try to serialize complex objects with =jld= (=hdf5= for Julia), then try to de-serialize on the Emacs side.

** Error handling

Very little at the moment.

We do capture exceptions thrown by Julia and return the exception type as a string to Emacs (+ emit some stdout). This is obviously brittle and needs work.

** Memory Management

Current tests are too simple for exploring this.

The only relevant code for this right now is in [[file:julia-core.c][julia-core.c]]:

#+BEGIN_EXAMPLE c
jl_value_t *val = jl_eval_string(str_arg);
...
JL_GC_PUSH1(&val);
emacs_value emacs_val = jl_to_elisp(env, val);
JL_GC_POP();
#+END_EXAMPLE

which ensures =val= isn't garbage collected by Julia while we convert it to an Emacs Lisp value.

** Concurrency

Currently, if Julia blocks, Emacs hangs. Julia is being compiled with threads enabled, so this might be avoidable.

FWIW, [[https://github.com/dzop/emacs-zmq][emacs-zmq]] spawns a slave Emacs process to handle polling channels. I hope that's not necessary here.

** Tests

...

** Benchmarks

- Round-trip speed test against Julia REPL and jupy-julia

** Development

While we're still relying on a patched Emacs, it would be nice to:

- provide a patch file for the =dlopen= tweak (one line)
- provide a container image with the patched pre-built Emacs (for testing)

** Open questions:

- Can we avoid modifying the =dlopen= call in the Emacs source?
  - This is the biggest current issue IMHO, since most users can't/won't modify their Emacs C code.
  - Maybe it can be fixed on Julia's side? Is it OK to require that flag?

- Can we build =femtolisp= as a shared library and link to it?
  - This would allow tightly interacting with the Julia's femtolisp parser, which is callable from C.
  - The Julia C API provides only top-level access to the parser (on purpose), but there are use-cases for tool development where it would be valuable.
  - This will likely require a (fork of / PR to) femtolisp, as it doesn't seem to currently build objects for use in shared libraries.
  - If the [[https://github.com/dzop/emacs-julia-parser/][emacs-julia-parser]] succeeds, this could be unnecessary.
    - However, as there is no spec for Julia's syntax, so *the femtolisp parser is the de-facto spec*!

** Open tasks

- Julia docs mention UInt128 and Int128 types, but there aren't box/unbox functions for them in =julia.h= near the others...


- Finish data marshalling layer
- Demo some new functionality leveraging sexprs
- Shell for inspecting Julia's state
- Async Julia eval
- Determine if we can hold on to several Julia sessions
- Determine if we can clear the state of an existing Julia session
-

** Debugging Notes

*** Compile libjulia with debugging symbols

#+BEGIN_SRC shell :dir ~/julia
make debug
#+END_SRC

*** Load debug version libjulia

#+BEGIN_SRC emacs-lisp
(module-load "/home/dan/treemax/.spacemacs.d/layers/treemax-julia/local/libjulia/libjulia-wrapper.so")
(libjulia--dlopen "/home/dan/julia/usr/lib/libjulia-debug.so")
#+END_SRC

*** Run Emacs under gdb

If using LD_LIBRARY_PATH, ensure you update it to point to include the path to =libjulia-debug.so=

#+BEGIN_SRC shell
LD_LIBRARY_PATH=... gdb --args ~/emacs-src/src/emacs
#+END_SRC

Then set a breakpoint somewhere in julia with a gdb command like:  =b /home/dan/julia/src/module.c:470=

Then the =run= gdb command to launch Emacs.

Load the debug library and do something that calls the code with the breakpoint.

Use gdb to debug.


* Misc
** Naming Conventions

The names for:

  - this project
  - the emacs library it exposes
  - the top-level C source file
  - the ".so" shared library

all try to follow conventions already set by other Emacs dynamic modules. You can find a list [[https://github.com/emacs-pe/emacs-modules][here]]. Please let me know if you find an inconsistency.
* Bugs to Report
** Embedding Julia docs show the use of jl_get_function, but that doesn't seem to be exported:

#+BEGIN_SRC c
STATIC_INLINE jl_function_t *jl_get_function(jl_module_t *m, const char *name)
{
    return (jl_function_t*)jl_get_global(m, jl_symbol(name));
}
#+END_SRC

#+BEGIN_SRC shell :exports both
nm /usr/local/lib/libjulia.so |  grep jl_get_function
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

Resorting to directly calling =jl_get_global= for now.
** Incorrect [[file:~/julia/src/julia_threads.h:://%20JULIA_ENABLE_THREADING%20is%20switched%20on%20in%20Make.inc%20if%20JULIA_THREADS%20is][comment in julia_threads.h]] regarding =JULIA_ENABLE_THREADING=.

Actually set to 1 always now in =Make.inc=

#+BEGIN_EXAMPLE make
# Enable threading with one thread
JULIA_THREADS := 1
#+END_EXAMPLE

#+BEGIN_EXAMPLE make
# Threads
ifneq ($(JULIA_THREADS), 0)
JCPPFLAGS += -DJULIA_ENABLE_THREADING -DJULIA_NUM_THREADS=$(JULIA_THREADS)
endif
#+END_EXAMPLE

Which means it's always on? Not sure how exporting jl_init ever works then:

#+BEGIN_EXAMPLE c
#ifdef JULIA_ENABLE_THREADING
// this helps turn threading compilation mismatches into linker errors
#define julia_init julia_init__threading
#define jl_init jl_init__threading
#define jl_init_with_image jl_init_with_image__threading
#endif
JL_DLLEXPORT void julia_init(JL_IMAGE_SEARCH rel);
JL_DLLEXPORT void jl_init(void);
JL_DLLEXPORT void jl_init_with_image(const char *julia_bindir,
                                     const char *image_relative_path);
#+END_EXAMPLE

Seems like the name =jl_init= will always be swapped for =julia_init__threading=, which has no definition!

Can confirm threading is enabled with:

#+BEGIN_EXAMPLE c
JL_DLLEXPORT int jl_threading_enabled(void)
{
#ifdef JULIA_ENABLE_THREADING
    return 1;
#else
    return 0;
#endif
}
#+END_EXAMPLE

#+BEGIN_EXAMPLE julia
ccall(:jl_threading_enabled, Cint, ())
#+END_EXAMPLE


* Acknowledgments

- [[https://github.com/dzop/emacs-zmq][emacs-zmq]] for inspiration and great examples. The first-load automatic compilation code was taken from here (and probably other things).
- John Kitchin for his [[https://github.com/jkitchin/emacs-modules][module helpers]].
- This thorough Emacs module documentation: http://phst.github.io/emacs-modules.html
