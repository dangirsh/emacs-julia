(require 'ffi)

;;; Utilities

(defun libjulia-under-to-hyphen (elisp-name)
  (replace-regexp-in-string (regexp-quote "-") "_" elisp-name t t))

;;; Primitive types

(defvar libjulia-primitive-type-map
  '((:julia-type "Bool"    :ffi-type :bool)
    (:julia-type "Int8"    :ffi-type :int8)
    (:julia-type "UInt8"   :ffi-type :uint8)
    (:julia-type "Int16"   :ffi-type :int16)
    (:julia-type "UInt16"  :ffi-type :uint16)
    (:julia-type "Int32"   :ffi-type :int32)
    (:julia-type "UInt32"  :ffi-type :uint32)
    (:julia-type "Int64"   :ffi-type :int64)
    (:julia-type "UInt64"  :ffi-type :uint64)
    (:julia-type "Int64"   :ffi-type :int64)
    (:julia-type "Float32" :ffi-type :float)
    (:julia-type "Float64" :ffi-type :double)
    ;; TODO: there are boxer for voidpointer, ssavevalue, slotnumber
    ;; TODO: there's also an unboxer for voidpointer
    ))

(defun libjulia-primitive-convert (from-type-name from-type-key to-type-key)
  (plist-get
   (seq-find
    #'(lambda (type-plist)
        (equal from-type-name (plist-get type-plist from-type-key)))
    libjulia-primitive-type-map)
   to-type-key))

(defun libjulia-primitive-julia-type-p (julia-type)
  (not (null (libjulia-primitive-convert julia-type :julia-type :julia-type))))

(defmacro libjulia-dolist-primitive-types (&rest body)
  `(dolist (type-entry libjulia-primitive-type-map)
     (pcase-let ((`(:julia-type ,julia-type  :ffi-type ,ffi-type) type-entry))
       (progn ,@body))))


;;; Arrays

(defun ffi-array-index-ref (array type index)
  (ffi-pointer+ array (* index (ffi--type-size type))))

(defun ffi-set-aref (array type index value)
  (ffi--mem-set
   (ffi-array-index-ref array type index)
   type
   value)
  ;; FIXME: this sanity check fails for user-ptr objects for some reason.
  ;; (unless (equal value (ffi-aref array type index))
  ;;   (error (format "Failed to set ffi array %s at index %s." array index)))
  )

;;; Binding macros

(defmacro libjulia-bind (name arg-types return-type)
  "Wrapper around define-ffi-function from the ffi library."
  (message (format "Generating Julia binding for %s." name))
  `(define-ffi-function
     ,name
     ,(libjulia-under-to-hyphen (symbol-name name))
     ,return-type
     ,arg-types
     libjulia.so))

(defmacro libjulia-bind-symbol (sym ffi-type)
  ;; ffi--dlsym returns a POINTER to the value of the sym in libjulia.so
  ;; If the symbol is itself a pointer, say of type *t, then dlsym effectively
  ;; returns a pointer of type **t. We use ffi--mem-ref here to dereference
  ;; the returned pointer immediately.
  ;; TODO: Is a simple setq the best option here?
  `(setq ,sym
         (ffi--mem-ref
          (ffi--dlsym
           ,(libjulia-under-to-hyphen (symbol-name sym)) (libjulia.so))
          ,ffi-type)))


;;; Boxing and Unboxing

(defun libjulia-get-jl-unbox-sym (julia-type)
  (intern (format "jl-unbox-%s" (downcase julia-type))))

(defun libjulia-get-jl-box-sym (julia-type)
  (intern (format "jl-box-%s" (downcase julia-type))))

(defun libjuila-gen-boxers-and-unboxers ()
  (libjulia-dolist-primitive-types
   (eval `(libjulia-bind
           ,(libjulia-get-jl-unbox-sym julia-type)
           (:pointer)
           ,ffi-type))
   (eval `(libjulia-bind
           ,(libjulia-get-jl-box-sym julia-type)
           (,ffi-type)
           :pointer))))

(defun libjulia-primitive-box (val julia-type)
  (unless (libjulia-primitive-julia-type-p julia-type)
    (error "Cannot box non-primitive type."))
  (let* ((box-f (libjulia-get-jl-box-sym julia-type)))
    (unless (functionp box-f)
      (error (format "Failed to lookup autogenerated box function %s." box-f)))
    (funcall box-f val)))

(defun libjulia-primitive-unbox (ptr julia-type)
  (unless (libjulia-primitive-julia-type-p julia-type)
    (error "Cannot unbox non-primitive type."))
  (let* ((unbox-f (libjulia-get-jl-unbox-sym julia-type)))
    (unless (functionp unbox-f)
      (error (format "Failed to lookup autogenerated unbox function %s." unbox-f)))
    (funcall unbox-f ptr)))

(defun libjulia-elisp-str-from-julia (ptr)
  (ffi-get-c-string (jl-string-ptr ptr)))

(defun libjulia-elisp-from-julia (ptr julia-type)
  (pcase julia-type
    ((pred libjulia-primitive-julia-type-p)
     (libjulia-primitive-unbox ptr julia-type))
    ("String"
     (libjulia-elisp-str-from-julia ptr))
    ;; If we can't convert to an Elisp type, return as a raw user-ptr.
    (_ ptr)))


;;; libjulia wrappers

(defun libjulia-eval-str (julia-expr-str)
  (with-ffi-string (julia-expr-c-string julia-expr-str)
    (let* ((ret-val-ptr (jl-eval-string julia-expr-c-string))
           (julia-type (ffi-get-c-string (jl-typeof-str ret-val-ptr))))
      (libjulia-elisp-from-julia ret-val-ptr julia-type))))

(defun libjulia-get-julia-type (julia-code-str)
  (ffi-get-c-string
   (jl-typeof-str
    (with-ffi-string (c-str-ptr julia-code-str)
      (jl-eval-string c-str-ptr)))))


(defun libjuila-jl-call (julia-func-name args ret-type)
  ;; (with-ffi-string (julia-func-name-c-str julia-func-name))
  ;; Here we reproduce the logic in julia.h for jl_get_function:
  ;; STATIC_INLINE jl_function_t *jl_get_function(jl_module_t *m, const char *name)
  ;; {
  ;; return (jl_function_t*)jl_get_global(m, jl_symbol(name));
  ;; }
  ;; Note that jl_get_function itself is not exported.
  (let* ((julia-func-name-c-string (ffi-make-c-string julia-func-name))
         (julia-func-symbol (jl-symbol julia-func-name-c-string))
         (func-ptr (jl-get-global jl-base-module julia-func-symbol))
         (boxed-args
          (mapcar
           #'(lambda (arg)
               (libjulia-primitive-box (car arg) (cdr arg)))
           args))
         (nargs (length args)))
    (define-ffi-array jl-call-args :pointer nargs)
    (dotimes (index nargs)
      (ffi-set-aref jl-call-args :pointer index (elt boxed-args index)))
    (libjulia-primitive-unbox
     (jl-call func-ptr jl-call-args nargs)
     ret-type)))


;;; Initialization

(defun libjuila-gen-function-bindings ()
  (libjulia-bind jl-string-ptr
                 (:pointer)
                 :pointer)
  (libjulia-bind jl-typeof-str
                 (:pointer)
                 :pointer)
  (libjulia-bind jl-eval-string
                 (:pointer)
                 :pointer)
  (libjulia-bind jl-get-global
                 (:pointer :pointer)
                 :pointer)
  (libjulia-bind jl-symbol
                 (:pointer)
                 :pointer)
  (libjulia-bind jl-call
                 (:pointer :pointer :int32)
                 :pointer))

(defun libjuila-gen-symbol-bindings ()
  (libjulia-bind-symbol jl-base-module :pointer))

(defun libjulia-init ()
  ;; Ugly workaround to being required to load libjulia with RTLD_GLOBAL. We load
  ;; it first via the wrapper, which has a custom dlopen call. Then, emacs-ffi
  ;; tries to re-load it via ltld, but it's already been loaded with the
  ;; RTLD_GLOBAL flag from the wrapper. Note that ltld docs claim their dlopen
  ;; shouldn't need RTLD_GLOBAL because "back-tracing". This doesn't seem to be
  ;; true for libjulia...
  (module-load "/home/dan/treemax/.spacemacs.d/layers/treemax-julia/local/libjulia/libjulia-wrapper.so")
  ;; (libjulia--dlopen "/usr/local/lib/libjulia.so")
  (libjulia--dlopen "libjulia-debug.so")

  ;; Now load the library again via emacs-ffi
  ;; (define-ffi-library libjulia.so "libjulia.so")
  (define-ffi-library libjulia.so "libjulia-debug.so")
  (define-ffi-function jl-init "jl_init" :void nil libjulia.so)
  (jl-init)
  (libjuila-gen-boxers-and-unboxers)
  (libjuila-gen-function-bindings)
  (libjuila-gen-symbol-bindings))

(libjulia-init)


(provide 'libjulia)
