(require 'ffi)
(require 'cl-lib)

;;; Utilities

(defun libjulia-hyphen-to-underscore (elisp-name)
  (replace-regexp-in-string (regexp-quote "-") "_" elisp-name t t))

(defun libjulia-remove-colon (sym-name)
  ;; FIXME: should only replace FIRST colon
  (replace-regexp-in-string (regexp-quote ":") "" sym-name t t))

;;; Primitive types

(defvar libjulia--type-plist
  '((:julia-type "Bool"    :ffi-type :bool)
    (:julia-type "Int8"    :ffi-type :int8)
    (:julia-type "UInt8"   :ffi-type :uint8)
    (:julia-type "Int16"   :ffi-type :int16)
    (:julia-type "UInt16"  :ffi-type :uint16)
    (:julia-type "Int32"   :ffi-type :int32)
    (:julia-type "UInt32"  :ffi-type :uint32)
    (:julia-type "Int64"   :ffi-type :int64)
    (:julia-type "UInt64"  :ffi-type :uint64)
    (:julia-type "Int64"   :ffi-type :int64)
    (:julia-type "Float32" :ffi-type :float)
    (:julia-type "Float64" :ffi-type :double)
    ;; TODO: there are boxer for voidpointer, ssavevalue, slotnumber
    ;; TODO: there's also an unboxer for voidpointer
    ))


(defvar libjulia-type-map
  (let ((hash-tbl (make-hash-table :test 'equal)))
    (dolist (type-entry libjulia--type-plist)
      (pcase-let ((`(:julia-type ,julia-type  :ffi-type ,ffi-type) type-entry))
        (puthash julia-type ffi-type hash-tbl)))
    hash-tbl)
  "A hash map from julia-type => ffi-type.")


(defun libjulia-primitive-julia-type-p (julia-type)
  (not (null (gethash julia-type libjulia-type-map))))


;;; Arrays

(defun ffi-array-index-ref (array type index)
  (ffi-pointer+ array (* index (ffi--type-size type))))

(defun ffi-set-aref (array type index value)
  (ffi--mem-set
   (ffi-array-index-ref array type index)
   type
   value)
  ;; FIXME: this sanity check fails for user-ptr objects for some reason.
  ;; (unless (equal value (ffi-aref array type index))
  ;;   (error (format "Failed to set ffi array %s at index %s." array index)))
  )

;;; Binding macros

(defmacro libjulia-bind (name arg-types return-type)
  "Wrapper around define-ffi-function from the ffi library."
  `(define-ffi-function
     ,name
     ,(libjulia-hyphen-to-underscore (symbol-name name))
     ,return-type
     ,arg-types
     libjulia.so))

(defmacro libjulia-bind-symbol (sym ffi-type)
  ;; ffi--dlsym returns a POINTER to the value of the sym in libjulia.so
  ;; If the symbol is itself a pointer, say of type *t, then dlsym effectively
  ;; returns a pointer of type **t. We use ffi--mem-ref here to dereference
  ;; the returned pointer immediately.
  ;; TODO: Is a simple setq the best option here?
  `(setq ,sym
         (ffi--mem-ref
          (ffi--dlsym
           ,(libjulia-hyphen-to-underscore (symbol-name sym)) (libjulia.so))
          ,ffi-type)))


;;; Boxing and Unboxing

(defun libjulia--get-jl-unbox-sym (julia-type)
  (intern (format "jl-unbox-%s" (downcase julia-type))))

(defun libjulia--get-jl-box-sym (julia-type)
  (intern (format "jl-box-%s" (downcase julia-type))))

(defun libjulia--gen-boxer-and-unboxer (julia-type ffi-type)
  (eval `(libjulia-bind
          ,(libjulia--get-jl-unbox-sym julia-type)
          (:pointer)
          ,ffi-type))
  (eval `(libjulia-bind
          ,(libjulia--get-jl-box-sym julia-type)
          (,ffi-type)
          :pointer)))

(defun libjuila-gen-all-boxers-and-unboxers ()
  (maphash #'libjulia--gen-boxer-and-unboxer libjulia-type-map))

(defun libjulia-primitive-box (val julia-type)
  (unless (libjulia-primitive-julia-type-p julia-type)
    (error "Cannot box non-primitive type."))
  (let* ((box-f (libjulia--get-jl-box-sym julia-type)))
    (unless (functionp box-f)
      (error "Failed to lookup autogenerated box function %s." box-f))
    (funcall box-f val)))

(defun libjulia-primitive-unbox (ptr julia-type)
  (unless (libjulia-primitive-julia-type-p julia-type)
    (error "Cannot unbox non-primitive type."))
  (let* ((unbox-f (libjulia--get-jl-unbox-sym julia-type)))
    (unless (functionp unbox-f)
      (error "Failed to lookup autogenerated unbox function %s." unbox-f))
    (funcall unbox-f ptr)))


;;; Value conversions

(defun libjulia-elisp-from-julia (julia-val-ptr)
  (when (and julia-val-ptr (not (ffi-pointer-null-p julia-val-ptr)))
    (let ((julia-type (ffi-get-c-string (jl-typeof-str julia-val-ptr))))
      (pcase julia-type
        ((pred libjulia-primitive-julia-type-p)
         (libjulia-primitive-unbox julia-val-ptr julia-type))
        ("String"
         (ffi-get-c-string (jl-string-ptr julia-val-ptr)))
        ("Symbol"
         (intern (format ":%s"
                         (ffi-get-c-string
                          (jl-symbol-name julia-val-ptr)))))
        ;; If we can't convert to an Elisp type, return as a raw user-ptr.
        (_ julia-val-ptr)))))

(defun libjulia-julia-from-elisp (elisp-val)
  (pcase elisp-val
    ((pred integerp)
     (libjulia-primitive-box elisp-val "Int64"))
    ((pred floatp)
     (libjulia-primitive-box elisp-val "Float64"))
    ((or 'nil 't)
     (libjulia-primitive-box elisp-val "Bool"))
    ((pred stringp)
     (jl-cstr-to-string (ffi-make-c-string elisp-val)))
    ((pred symbolp)
     (jl-symbol (ffi-make-c-string
                 (libjulia-remove-colon
                  (symbol-name elisp-val)))))
    ;; If we can't convert to a Julia type, pass the raw user-ptr through.
    ;; FIXME: check it's a user-ptr type here!
    (_ elisp-val)))


;;; libjulia wrappers

(defun libjulia-eval-str (julia-expr-str)
  (with-ffi-string (julia-expr-c-string julia-expr-str)
    (libjulia-elisp-from-julia (jl-eval-string julia-expr-c-string))))


(defun libjulia-jl-call (julia-func-name args &optional julia-module-name)
  (let* ((julia-module (libjulia-get-module julia-module-name))
         (func-ptr (jl-get-function julia-module julia-func-name))
         (julia-args (mapcar #'libjulia-julia-from-elisp args))
         (nargs (length julia-args)))
    (define-ffi-array jl-call-args :pointer nargs)
    (dotimes (index nargs)
      (ffi-set-aref jl-call-args :pointer index (elt julia-args index)))
    (libjulia-elisp-from-julia (jl-call func-ptr jl-call-args nargs))))


;;; Reimplementations
;; We can't bind to some things in julia.h (like static functions and #defines)
;; So, we reimplement them here in elisp.

(defun jl-symbol-name (julia-symbol-ptr)
  ;; FIXME: Don't hardcode the struct size!
  (let ((sizeof-jl-sym-t 24))
    (ffi-get-c-string (ffi-pointer+ julia-symbol-ptr sizeof-jl-sym-t))))

(defun jl-get-function (julia-module-ptr julia-func-name)
  "Elisp version of jl_get_function from julia.h:

  STATIC_INLINE jl_function_t *jl_get_function(jl_module_t *m, const char *name) {
     return (jl_function_t*)jl_get_global(m, jl_symbol(name));
  }"
  (libjulia-safe-get
   (jl-get-global julia-module-ptr (jl-symbol-lookup
                                    (ffi-make-c-string julia-func-name)))
   (format "Failed to find function %s." julia-func-name)))

;;; Helpers

(defmacro libjulia-safe-get (unsafe-get-form error-msg)
  `(let ((ptr ,unsafe-get-form))
     (when (ffi-pointer-null-p ptr)
       (error ,error-msg))
     ptr))

(defun libjulia-get-module (&optional julia-module-name)
  "Default is Base"
  ;; TODO: assert module-name is an elisp string or nil
  (libjulia-safe-get
   (jl-get-global jl-main-module
                  (jl-symbol
                   (ffi-make-c-string (or julia-module-name "Base"))))
   (format "Failed to lookup module %s" julia-module-name)))


;;; Initialization

(defun libjuila-gen-function-bindings ()
  (libjulia-bind jl-cstr-to-string
                 (:pointer)
                 :pointer)
  (libjulia-bind jl-string-ptr
                 (:pointer)
                 :pointer)
  (libjulia-bind jl-typeof-str
                 (:pointer)
                 :pointer)
  (libjulia-bind jl-eval-string
                 (:pointer)
                 :pointer)
  (libjulia-bind jl-toplevel-eval
                 (:pointer :pointer)
                 :pointer)
  (libjulia-bind jl-get-global
                 (:pointer :pointer)
                 :pointer)
  (libjulia-bind jl-symbol
                 (:pointer)
                 :pointer)
  (libjulia-bind jl-symbol-lookup
                 (:pointer)
                 :pointer)
  (libjulia-bind jl-call
                 (:pointer :pointer :int32)
                 :pointer))

(defun libjuila-gen-symbol-bindings ()
  (libjulia-bind-symbol jl-main-module :pointer)
  (libjulia-bind-symbol jl-base-module :pointer)
  (when (or
         (ffi-pointer-null-p jl-main-module)
         (ffi-pointer-null-p jl-base-module))
    (error "Failure getting pointers to core Julia module(s).")))

(defconst libjulia-wrapper-module-file
  (when module-file-suffix
    (expand-file-name
     (concat "libjulia-wrapper" module-file-suffix)
     ;; (file-name-directory (locate-library "libjulia"))
     (file-name-directory default-directory)))
  "The module file for libjulia or nil if modules are not supported.")

(defun libjulia-wrapper-load ()
  (if libjulia-wrapper-module-file
      (if (file-exists-p libjulia-wrapper-module-file)
          (progn
            (module-load libjulia-wrapper-module-file))
        (when (y-or-n-p "libjulia-wrapper module not found. Build it? ")
          (let (;; (default-directory (file-name-directory (locate-library "libjulia")))
                (default-directory (file-name-directory default-directory)))
            (cl-labels
                ((load-libjulia
                  (_buf status)
                  (if (string= status "finished\n")
                      (libjulia-wrapper-load)
                    (message "Something went wrong when compiling the libjulia-wrapper module!"))
                  (remove-hook 'compilation-finish-functions #'load-libjulia)
                  (exit-recursive-edit)))
              (add-hook 'compilation-finish-functions #'load-libjulia)
              (compile "make")
              (recursive-edit)))))
    (user-error "Modules are not supported")))


(defun libjulia-load ()
  "Ugly workaround to being required to dlopen libjulia with
  RTLD_GLOBAL set. We load it first via the wrapper, which has a
  custom dlopen call. Then, emacs-ffi tries to re-load it via
  pltld, but it's already been loaded with the RTLD_GLOBAL flag
  from the wrapper. Note that ltld docs claim their dlopen
  shouldn't need RTLD_GLOBAL, but this doesn't seem to be true
  for libjulia..."
  (libjulia-wrapper-load)
  (libjulia--dlopen "libjulia-debug.so")
  (define-ffi-library libjulia.so "libjulia-debug")
  ;; Would be nice to do this in libjuila-gen-function-bindings with
  ;; libjulia-bind, but that gives a sefault for some reason.
  (define-ffi-function jl-init "jl_init" :void nil libjulia.so)
  (jl-init))

(defun libjulia-init ()
  (libjulia-load)
  (libjuila-gen-all-boxers-and-unboxers)
  (libjuila-gen-function-bindings)
  (libjuila-gen-symbol-bindings))


(libjulia-init)

(provide 'libjulia)
